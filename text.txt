# Импорты, этот файл - основные функции бота
from aiogram import F, Router, Bot, types
from aiogram.filters import Command, CommandStart
from aiogram.types import Message, CallbackQuery
from aiogram.fsm.state import State, StatesGroup
from aiogram.fsm.context import FSMContext
from aiogram.enums import ParseMode
from app.database import add_ban, remove_ban, is_banned, get_all_bans, get_ban_info, add_to_queue
from config import CHANNEL_ID, XYREX_ID, XYREX_ANKETS, TOPIC_ID
import app.ceyboards as kb
import json


DATABASE = 'bans.db'
import aiosqlite



# Классы


router = Router()


class Reg(StatesGroup):
    opinion_type = State()
    group_members = State()
    name = State()
    versus = State()
    uslovie = State()
    formatbattla = State()
    load_media = State()
    media_group = State()
    public = State()

class Proofbattle(StatesGroup):
    names = State()
    verses = State()
    tags = State()
    regone = State()
    regtwo = State()
    rules = State()
    confirm = State()
    selectone = State()
    selecttwo = State()


# Баны


def parse_time(time_str: str) -> int:
    time_units = {
        'минут': 60,
        'час': 3600,
        'день': 86400
    }
    for unit, multiplier in time_units.items():
        if unit in time_str:
            return int(time_str.split()[0]) * multiplier
    return 86400


@router.message(CommandStart(), F.chat.type == 'private')
async def cmd_start(message: Message):
    if await is_banned(message.chat.id):
        return await message.reply('Вы были забанены.')
    await message.reply('Привет, желаешь опубликовать мнение или организовать пб?', reply_markup=kb.main)


@router.message(Command("banxr"), F.chat.id == CHANNEL_ID)
async def ban_user(message: Message):
    try:
        args = message.text.split()[1:]
        if not args:
            return await message.answer("Использование: /banxr <ID> [время] [причина]")
        
        user_id = args[0]
        duration = parse_time(' '.join(args[1:-1])) if len(args) > 2 else 86400
        reason = args[-1] if len(args) > 2 else "Без причины"
        
        try:
            await add_ban(int(user_id), duration, reason)
            ban_info = await get_ban_info(int(user_id))
            await message.answer(f"Пользователь {user_id} забанен до {ban_info['ban_until']} по причине: {reason}")
        except ValueError:
            await message.answer("Неверный ID пользователя")
    except Exception as e:
        await message.answer(f"Ошибка: {str(e)}") 


@router.message(Command("unbanxr"), F.chat.id == CHANNEL_ID)
async def unban_user(message: Message):
    try:
        args = message.text.split()[1:]
        if not args:
            return await message.answer("Использование: /unbanxr <ID>")
        
        try:
            user_id = int(args[0])
            await remove_ban(user_id)
            await message.answer(f"Пользователь {user_id} разбанен")
        except ValueError:
            await message.answer("Неверный ID пользователя")
    except Exception as e:
        await message.answer(f"Ошибка: {str(e)}")  


@router.message(Command("banslist"), F.chat.id == CHANNEL_ID)
async def list_bans(message: Message):
    bans = await get_all_bans()
    
    if not bans:
        return await message.answer("Список забаненных пользователей пуст.")
    
    response = "<b>Забаненные пользователи:</b>\n\n"
    for ban in bans:
        user_id = ban['user_id']
        ban_until = ban['ban_until'].strftime("%d.%m.%Y %H:%M")
        reason = ban['reason']
        response += (
            f"• <b>ID:</b> {user_id}\n"
            f"  <b>До:</b> {ban_until}\n"
            f"  <b>Причина:</b> {reason}\n\n"
        )    
    await message.answer(response, parse_mode=ParseMode.HTML)


# ПБ


@router.callback_query(F.data == 'PB')
async def pbanswer(callback: CallbackQuery, state: FSMContext):
    await callback.message.edit_text(
        'Введите имена персонажей, по порядку, через запятую, с пробелом, с большой буквы.')
    await state.set_state(Proofbattle.names)


@router.message(Proofbattle.names)
async def pbnames(message: Message, state: FSMContext):
    nameslist = message.text.split(',')
    await state.update_data(names=nameslist)
    await state.set_state(Proofbattle.verses)
    await message.answer(text='Введите названия произведений/версов, по порядку, сначала для 1 персонажа,'
                              ' потом для 2, через запятую, с пробелом, с большой буквы.')


@router.message(Proofbattle.verses)
async def pbverses(message: Message, state: FSMContext):
    verseslist = message.text.split(',')
    await state.update_data(verses=verseslist)
    await state.set_state(Proofbattle.tags)
    await message.answer(text='Введите теги игроков, по порядку, через запятую, с пробелом.')


@router.message(Proofbattle.tags)
async def pbtags(message: Message, state: FSMContext):
    tagslist = message.text.split(',')
    await state.update_data(tags=tagslist)
    await message.answer(text='Выберите формат ПБ.',
                         reply_markup=kb.pbformat)


@router.callback_query(F.data == 'classic_f')
async def five_pb(callback: CallbackQuery, state: FSMContext):
    await callback.answer('Выбранный формат: тактика')
    await state.update_data(formatbattla='https://t.me/c/2235550385/16')
    await callback.message.edit_text(text='Отправьте условия вашего баттла, если таковых нет, напишите "нет"')
    await state.set_state(Proofbattle.rules)


@router.callback_query(F.data == 'hodi_f')
async def five_pb(callback: CallbackQuery, state: FSMContext):
    await callback.answer('Выбранный формат: ходы')
    await state.update_data(formatbattla='https://t.me/c/2235550385/15')
    await callback.message.edit_text(text='Отправьте условия вашего баттла, если таковых нет, напишите "нет"')
    await state.set_state(Proofbattle.rules)


@router.message(Proofbattle.rules)
async def pbtags(message: Message, state: FSMContext, bot: Bot):
    forward_message = await message.forward(chat_id=XYREX_ANKETS)
    forward_message_id = forward_message.message_id
    chat = await bot.get_chat(XYREX_ANKETS)
    message_link = f"https://t.me/{chat.username}/{forward_message_id}"
    await state.update_data(rules=message_link)
    await message.answer(text='Отправьте анкету(регу) сначала первого игрока, обязательно с фото или видео персонажа.')
    await state.set_state(Proofbattle.regone)


@router.message(Proofbattle.regone)
async def pbregs_one(message: Message, state: FSMContext, bot: Bot):
    if message.photo:
        media_type = "photo"
        media_id = message.photo[-1].file_id
    elif message.video:
        media_type = "video"
        media_id = message.video.file_id
    else:
        await message.answer("❌ Нужно отправить фото или видео!")
        await state.clear()
        return

    await state.update_data(
        media1_type=media_type,
        media1_id=media_id,
        pbsher=message.from_user.id,
        username=message.from_user.username
    )

    try:
        forward_message = await message.forward(chat_id=XYREX_ANKETS)
        chat = await bot.get_chat(XYREX_ANKETS)
        message_link = f"https://t.me/{chat.username}/{forward_message.message_id}"
        await state.update_data(link_one=message_link)
        await message.answer("✅ Анкета первого игрока принята! Теперь отправьте анкету второго игрока.")
        await state.set_state(Proofbattle.regtwo)
    except Exception as e:
        await message.answer(f"❌ Ошибка при обработке анкеты: {str(e)}")
        await state.clear()


@router.message(Proofbattle.regtwo)
async def pbregs_two(message: Message, state: FSMContext, bot: Bot):
    if message.photo:
        media_type = "photo"
        media_id = message.photo[-1].file_id
    elif message.video:
        media_type = "video"
        media_id = message.video.file_id
    else:
        await message.answer("❌ Нужно отправить фото или видео!")
        await state.clear()
        return

    await state.update_data(
        media2_type=media_type,
        media2_id=media_id
    )

    try:
        forward_message = await message.forward(chat_id=XYREX_ANKETS)
        chat = await bot.get_chat(XYREX_ANKETS)
        message_link = f"https://t.me/{chat.username}/{forward_message.message_id}"
        await state.update_data(link_two=message_link)
        
        data = await state.get_data()
        caption = f"""
<blockquote><b>ПЕРСОНАЛЬНЫЙ ПРУФ-БАТТЛ</b></blockquote>

Player 1: {data['tags'][0]}
 <b><a href="{data['link_one']}">{data['names'][0]}</a> — «{data['verses'][0]}»</b>


    <b>⋆ V-E-R-S-U-S ⋆</b>
            
 <b><a href="{data['link_two']}">{data['names'][1]}</a> — «{data['verses'][1]}»</b>
<b>Player 2: {data['tags'][1]}</b>


➥「<a href='{data['formatbattla']}'>правила боев</a>」
➥「<a href='https://t.me/xyrex_realm/27510'>список судей</a>」
➥「<a href='https://t.me/Xyrex_Fights/12643'>условия баттла</a>」
"""

        media_group = []
        
        if data['media1_type'] == 'photo':
            media_group.append(types.InputMediaPhoto(media=data["media1_id"], caption=caption, parse_mode=ParseMode.HTML))
        else:
            media_group.append(types.InputMediaVideo(media=data["media1_id"], caption=caption, parse_mode=ParseMode.HTML))
        
        if data['media2_type'] == 'photo':
            media_group.append(types.InputMediaPhoto(media=data["media2_id"]))
        else:
            media_group.append(types.InputMediaVideo(media=data["media2_id"]))
        
        soo = await bot.send_media_group(chat_id=data['pbsher'], media=media_group)
        message_id = [msg.message_id for msg in soo]
        await state.update_data(text=caption)
        await state.update_data(soo_id=message_id[0])
        await bot.send_message(
            chat_id=data['pbsher'],
            text='Все ли верно?\nПри нажатии на галку ПБ отправится на модерацию.',
            reply_markup=kb.accept
        )
        await state.set_state(Proofbattle.selecttwo)
        
    except Exception as e:
        await message.answer(f"❌ Ошибка при формировании поста: {str(e)}")
        await state.clear()

    

@router.callback_query(F.data.in_(["right", "wrong"]))
async def five_pb(callback: CallbackQuery, state: FSMContext, bot: Bot):
    if callback.data == 'right':
        try:
            data = await state.get_data()
            
            required_keys = ['media1_id', 'media2_id', 'link_one', 'link_two', 
                            'names', 'verses', 'tags', 'formatbattla', 'text',
                            'pbsher', 'username']
            for key in required_keys:
                if key not in data:
                    raise KeyError(f"Missing required key: {key}")

            media_group = []
            
            if data.get('media1_type') == 'photo':
                media_group.append(types.InputMediaPhoto(
                    media=data["media1_id"], 
                    caption=data['text'], 
                    parse_mode=ParseMode.HTML
                ))
            else:
                media_group.append(types.InputMediaVideo(
                    media=data["media1_id"], 
                    caption=data['text'], 
                    parse_mode=ParseMode.HTML
                ))

            if data.get('media2_type') == 'photo':
                media_group.append(types.InputMediaPhoto(
                    media=data["media2_id"]
                ))
            else:
                media_group.append(types.InputMediaVideo(
                    media=data["media2_id"]
                ))

            await bot.send_media_group(
                chat_id=CHANNEL_ID, 
                media=media_group, 
                message_thread_id=TOPIC_ID
            )

            await bot.send_poll(
                chat_id=CHANNEL_ID,
                question='⚔️ОБСУЖДЕНИЕ БАТТЛА⚔️\nКто победит по вашему мнению?',
                options=data['names'],
                is_anonymous=True,
                type='regular',
                message_thread_id=TOPIC_ID,
                reply_markup=kb.publicpb
            )

            await bot.send_message(
                chat_id=CHANNEL_ID,
                message_thread_id=TOPIC_ID,
                text=f'ID пользователя: {data["pbsher"]}\n'
                     f'Username: @{data["username"]}\n'
                     f'Команда для бана: /banxr {data["pbsher"]}'
            )

            await callback.message.edit_text(
                '✅ Ожидайте проверку. Если баттл долго не начинается, '
                'обратитесь к организаторам.\n'
                'Чтобы начать заново, используйте /start'
            )
            await state.clear()

        except KeyError as e:
            await callback.message.answer(
                f'❌ Ошибка при обработке данных: {str(e)}\n'
                'Пожалуйста, начните регистрацию заново',
                reply_markup=kb.main
            )
            await state.clear()

        except Exception as e:
            await callback.message.answer(
                '❌ Произошла непредвиденная ошибка\n'
                'Попробуйте начать регистрацию заново',
                reply_markup=kb.main
            )
            await state.clear()

    else:
        await callback.answer('Пост отменен')
        await callback.message.edit_text(
            '❌ Ваш пост отменен\n'
            'Чтобы начать заново, используйте /start'
        )
        await state.clear()


@router.callback_query(F.data.in_(["publicpb", "nopublic"]))
async def handle_callback(call: CallbackQuery):
    if call.data == "publicpb":
        try:
            message_ids = json.dumps([call.message.message_id])
            await add_to_queue(post_type='pb', post_id=call.message.message_id, message_ids=message_ids)
            await call.answer("✅ Пост добавлен в очередь на публикацию")
        except Exception as e:
            await call.answer("❌ Ошибка при добавлении в очередь")
            print(f"Ошибка очереди: {str(e)}")
    elif call.data == "nopublic":
        await call.message.delete()
        await call.answer("🗑 Бой отменен")


@router.callback_query(F.data == 'mnenie')
async def mnenie_post(callback: CallbackQuery, state: FSMContext):
    await callback.answer()
    await callback.message.edit_text(
        '🎭 Выберите тип мнения:',
        reply_markup=kb.opinion_type_select
    )
    await state.set_state(Reg.opinion_type)


@router.callback_query(F.data.in_(['single', 'group']), Reg.opinion_type)
async def process_opinion_type(callback: CallbackQuery, state: FSMContext):
    await state.update_data(opinion_type=callback.data)
    if callback.data == 'group':
        await callback.message.answer('👥 Введите теги/ники участников через запятую:')
        await state.set_state(Reg.group_members)
    else:
        await callback.message.answer('🎭 Введите имя персонажа:')
        await state.set_state(Reg.name)


@router.message(Reg.name)
async def process_name(message: Message, state: FSMContext):
    await state.update_data(name=message.text)
    await message.answer('Введите имена персонажей/вселенных через запятую:')
    await state.set_state(Reg.versus)


@router.message(Reg.versus)
async def process_versus(message: Message, state: FSMContext):
    versus = '\n'.join([f'➣ {v.strip()}' for v in message.text.split(',')])
    await state.update_data(versus=versus)
    await message.answer('Введите условия баттла:')
    await state.set_state(Reg.uslovie)


@router.message(Reg.uslovie)
async def process_uslovie(message: Message, state: FSMContext):
    await state.update_data(uslovie=message.text)
    await message.answer('Выберите формат обсуждения:', reply_markup=kb.formatselect)
    await state.set_state(Reg.formatbattla)


@router.callback_query(F.data.in_(['pb_format', 'gch', 'discussion_format']), Reg.formatbattla)
async def process_format(callback: CallbackQuery, state: FSMContext):
    format_text = {
        'pb_format': 'пруфбаттл',
        'gch': 'голосовой чат',
        'discussion_format': 'дискуссия'
    }[callback.data]

    await state.update_data(formatbattla=format_text)
    await callback.message.answer('📸 Отправьте фото/видео персонажа:')
    await callback.message.delete()
    await state.set_state(Reg.load_media)


@router.message(Reg.group_members)
async def process_group_members(message: Message, state: FSMContext):
    members = [m.strip() for m in message.text.split(',')]
    await state.update_data(members=members)
    await message.answer('🎭 Введите имя персонажа:')
    await state.set_state(Reg.name)


@router.message(Reg.load_media, F.photo | F.video)
async def process_media(message: Message, state: FSMContext, bot: Bot):
    data = await state.get_data()
    media_type = 'photo' if message.photo else 'video'
    media_id = message.photo[-1].file_id if media_type == 'photo' else message.video.file_id

    if data['opinion_type'] == 'group':
        media_list = data.get('media_list', [])
        media_list.append((media_type, media_id))
        await state.update_data(media_list=media_list)
        
        
        if len(media_list) == len(data['members']):
            caption = (
                f"<b>⚔️ ПЕРСОНАЛЬНАЯ ПОЗИЦИЯ</b>\n"
                f"<b>— @{message.from_user.username}</b>\n"
                f"➥ <b><u>{data['name']}</u> аннигилирует всех перечисленных:</b>\n"
                f"<blockquote><b>{data['versus']}</b></blockquote>\n"
                f"<b>Условия баттла: {data['uslovie']}</b>\n"
                f"<b>Формат: {data['formatbattla']}</b>"
            )
            media_group = []
            for mt, mid in media_list:
                media = types.InputMediaPhoto(media=mid) if mt == 'photo' else types.InputMediaVideo(media=mid)
                media_group.append(media)
            media_group[0].caption = caption
            media_group[0].parse_mode = ParseMode.HTML
            
            sent_msgs = await message.answer_media_group(media=media_group, reply_markup=kb.public)
            message_ids = [msg.message_id for msg in sent_msgs]
            
            async with aiosqlite.connect(DATABASE) as db:
                cursor = await db.execute('''
                    INSERT INTO opinions (opinion_type, name, versus, uslovie, formatbattla, media_id, author, username)
                    VALUES (?, ?, ?, ?, ?, ?, ?, ?)
                ''', (
                    data['opinion_type'],
                    data['name'],
                    data['versus'],
                    data['uslovie'],
                    data['formatbattla'],
                    json.dumps([(mt, mid) for mt, mid in media_list]),
                    json.dumps(data['members']),
                    message.from_user.username
                ))
                await db.commit()
                opinion_id = cursor.lastrowid
            
            await add_to_queue(post_type='opinion', post_id=opinion_id, message_ids=json.dumps(message_ids))
            await state.clear()
    else:
        caption = (
            f"<b>⚔️ ПЕРСОНАЛЬНАЯ ПОЗИЦИЯ</b>\n"
            f"<b>— @{message.from_user.username}</b>\n"
            f"➥ <b><u>{data['name']}</u> аннигилирует всех перечисленных:</b>\n"
            f"<blockquote><b>{data['versus']}</b></blockquote>\n"
            f"<b>Условия баттла: {data['uslovie']}</b>\n"
            f"<b>Формат: {data['formatbattla']}</b>"
        )

        if media_type == 'photo':
            sent_msg = await message.answer_photo(
                photo=media_id,
                caption=caption,
                parse_mode=ParseMode.HTML,
                reply_markup=kb.public
            )
        else:
            sent_msg = await message.answer_video(
                video=media_id,
                caption=caption,
                parse_mode=ParseMode.HTML,
                reply_markup=kb.public
            )

        async with aiosqlite.connect(DATABASE) as db:
            cursor = await db.execute('''
                INSERT INTO opinions (opinion_type, name, versus, uslovie, formatbattla, media_type, media_id, author, username)
                VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
            ''', (
                data['opinion_type'],
                data['name'],
                data['versus'],
                data['uslovie'],
                data['formatbattla'],
                media_type,
                media_id,
                json.dumps([message.from_user.username]),
                message.from_user.username
            ))
            await db.commit()
            opinion_id = cursor.lastrowid

        await add_to_queue(post_type='opinion', post_id=opinion_id)
        await state.clear()

@router.callback_query(F.data.in_(["yes", "no"]))
async def handle_callback(call: CallbackQuery, state: FSMContext, bot: Bot):
    if call.data == "yes":
        try:
            data = await state.get_data()
            message_ids = [call.message.message_id]

            await add_to_queue(
                message_ids=message_ids,
                chat_id=CHANNEL_ID,
                topic_id=TOPIC_ID,
                post_type='opinion',
                additional_data=json.dumps(data)
            )
            await call.answer("✅ Мнение отправлено на модерацию!")
        except Exception as e:
            await call.answer("❌ Ошибка при добавлении в очередь")
            print(f"Ошибка: {str(e)}")
    else:
        await call.message.delete()
        await call.answer("❌ Пост отменен")
    await state.clear()


# data = await state.get_data()
    # await message.answer_photo(
    #     photo=data['photo'],
    #     caption=f'<b>⚔️ Персональная позиция⚔️\n</b>'
    #             f'\n'
    #             f'<b>— @{data["username"]}\n</b>'
    #             f'\n'
    #             f'➥ <b><u>{data["name"]}</u> аннигилирует всех нижеперечисленных персонажей/вселенных:</b>\n'
    #             f'<blockquote><b>{data["versus"]}</b></blockquote>\n'
    #             f'<b>Условия баттла: {data["uslovie"]}</b>\n'
    #             f'<b>Формат: {data["formatbattla"]}</b>',
    #     parse_mode=ParseMode.HTML
    # )

    # data = await state.get_data()
    # await bot.send_photo(
    #     chat_id=CHANNEL_ID,
    #     message_thread_id=TOPIC_ID,
    #     photo=data['photo'],
    #     caption=f'<b>⚔️ Персональная позиция⚔️\n</b>'
    #             f'\n'
    #             f'<b>— @{data["username"]}\n</b>'
    #             f'\n'
    #             f'➥ <b><u>{data["name"]}</u> аннигилирует всех нижеперечисленных персонажей/вселенных:</b>\n'
    #             f'<blockquote><b>{data["versus"]}</b></blockquote>\n'
    #             f'<b>Условия баттла: {data["uslovie"]}</b>\n'
    #             f'<b>Формат: {data["formatbattla"]}</b>',
    #     parse_mode=ParseMode.HTML,
    #     reply_markup=kb.public
    # )
    # user_id = message.from_user.id
    # username = message.from_user.username
    # full_name = message.from_user.full_name
    # await bot.send_message(chat_id=CHANNEL_ID,
    #                        message_thread_id=TOPIC_ID,
    #                        text=f'ID пользователя:{user_id}\n'
    #                             f'Тег: @{username}, ник, если нету тега: {full_name}'
    #                             f'Чтобы забанить "/banxr ID"\n'
    #                             f'Для разбана "/unbanxr ID"')
    # await message.answer(text='Ваше мнение было отправлено на проверку модерации, вам осталось только подождать!\n'
    #                           "Чтобы начать снова, пропишите команду /start")
    # await state.clear()


# @router.callback_query(F.data.in_(["yes", "no"]))
# async def handle_callback(call: CallbackQuery, state: FSMContext, bot: Bot):
#     if call.data == "yes":
#         try:
#             data = await state.get_data()
#             message_ids = [call.message.message_id]
            
#             # Добавляем в очередь с правильными параметрами
#             await add_to_queue(
#                 message_ids=message_ids,
#                 chat_id=CHANNEL_ID,
#                 topic_id=TOPIC_ID,
#                 post_type='opinion',
#                 additional_data=json.dumps(data)
#             )
#             await call.answer("✅ Мнение отправлено на модерацию!")
#         except Exception as e:
#             await call.answer("❌ Ошибка при добавлении в очередь")
#             print(f"Ошибка: {str(e)}")
#     else:
#         await call.message.delete()
#         await call.answer("❌ Пост отменен")
#     await state.clear()

import aiosqlite
from datetime import datetime, timedelta
import json
from config import XYREX_ID, CHANNEL_ID, TOPIC_ID


DATABASE = 'bans.db'


async def create_db():
    async with aiosqlite.connect(DATABASE) as db:
        await db.execute('''
            CREATE TABLE IF NOT EXISTS bans (
                user_id INTEGER PRIMARY KEY,
                ban_until TIMESTAMP NOT NULL,
                reason TEXT DEFAULT 'No reason specified'
            )
        ''')
        await db.execute('''
            CREATE TABLE IF NOT EXISTS proofbattles (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                names JSON NOT NULL,
                verses JSON NOT NULL,
                tags JSON NOT NULL,
                formatbattla TEXT NOT NULL,
                rules TEXT NOT NULL,
                media1_type TEXT NOT NULL,
                media1_id TEXT NOT NULL,
                media2_type TEXT NOT NULL,
                media2_id TEXT NOT NULL,
                text TEXT NOT NULL,
                pbsher INTEGER NOT NULL,
                username TEXT NOT NULL
            )
        ''')
        await db.execute('''
            CREATE TABLE IF NOT EXISTS opinions (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                opinion_type TEXT NOT NULL,
                name TEXT NOT NULL,
                versus TEXT NOT NULL,
                uslovie TEXT NOT NULL,
                formatbattla TEXT NOT NULL,
                media_list JSON NOT NULL, 
                media_list JSON NOT NULL,
                username TEXT NOT NULL
            )
        ''')
        await db.execute('''
            CREATE TABLE IF NOT EXISTS post_queue (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                post_type TEXT NOT NULL,
                db_post_id INTEGER NOT NULL,
                scheduled_time TIMESTAMP NOT NULL,
                status TEXT DEFAULT 'pending',
                moderation_message_ids TEXT NOT NULL
                attempts INTEGER DEFAULT 0
            )
        ''')
        await db.commit()


async def add_ban(user_id: int, duration: int = 86400, reason: str = "No reason"):
    ban_until = datetime.now() + timedelta(seconds=duration)
    async with aiosqlite.connect(DATABASE) as db:
        await db.execute('''
            INSERT OR REPLACE INTO bans (user_id, ban_until, reason)
            VALUES (?, ?, ?)
        ''', (user_id, ban_until.timestamp(), reason))
        await db.commit()


async def remove_ban(user_id: int):
    async with aiosqlite.connect(DATABASE) as db:
        await db.execute('DELETE FROM bans WHERE user_id = ?', (user_id,))
        await db.commit()


async def is_banned(user_id: int) -> bool:
    async with aiosqlite.connect(DATABASE) as db:
        cursor = await db.execute('SELECT ban_until FROM bans WHERE user_id = ?', (user_id,))
        result = await cursor.fetchone()
        
        if result:
            ban_until = datetime.fromtimestamp(result[0])
            if datetime.now() > ban_until:
                await remove_ban(user_id)
                return False
            return True
    return False


async def get_ban_info(user_id: int) -> dict:
    async with aiosqlite.connect(DATABASE) as db:
        cursor = await db.execute('SELECT ban_until, reason FROM bans WHERE user_id = ?', (user_id,))
        result = await cursor.fetchone()
        
        if result:
            return {
                'ban_until': datetime.fromtimestamp(result[0]),
                'reason': result[1]
            }
    return None


async def get_all_bans() -> list:
    async with aiosqlite.connect(DATABASE) as db:
        cursor = await db.execute('SELECT user_id, ban_until, reason FROM bans')
        rows = await cursor.fetchall()
        return [
            {
                'user_id': row[0],
                'ban_until': datetime.fromtimestamp(row[1]),
                'reason': row[2]
            } for row in rows
        ]


async def cleanup_expired_bans():
    async with aiosqlite.connect(DATABASE) as db:
        await db.execute('DELETE FROM bans WHERE ban_until < ?', (datetime.now().timestamp(),))
        await db.commit()


async def add_to_queue(post_type: str, post_id: int, message_ids: str):
    async with aiosqlite.connect(DATABASE) as db:
        cursor = await db.execute('''
            SELECT MAX(scheduled_time) FROM post_queue WHERE status = 'pending'
        ''')
        last_time = await cursor.fetchone()
        next_time = datetime.now() + timedelta(minutes=1) 
        if last_time[0]:
            last_time = datetime.fromtimestamp(last_time[0])
            next_time = max(next_time, last_time + timedelta(minutes=1))
        
        await db.execute('''
            INSERT INTO post_queue (post_type, post_id, message_ids, scheduled_time)
            VALUES (?, ?, ?, ?)
        ''', (post_type, post_id, message_ids, next_time.timestamp()))
        await db.commit()


async def get_next_post():
    async with aiosqlite.connect(DATABASE) as db:
        db.row_factory = aiosqlite.Row
        
        cursor = await db.execute('''
            SELECT * FROM post_queue 
            WHERE status = 'pending' 
            AND scheduled_time <= ?
            ORDER BY scheduled_time 
            LIMIT 1
        ''', (datetime.now().timestamp(),))
        
        return await cursor.fetchone()


async def update_post(post_id: int, status: str):
    async with aiosqlite.connect(DATABASE) as db:
        await db.execute('''
            UPDATE post_queue 
            SET status = ?, 
                attempts = attempts + 1 
            WHERE id = ?
        ''', (status, post_id))
        await db.commit()


async def cleanup_queue():
    async with aiosqlite.connect(DATABASE) as db:
        await db.execute('''
            DELETE FROM post_queue 
            WHERE scheduled_time < ?
        ''', ((datetime.now() - timedelta(days=3)).timestamp(),))
        await db.commit()