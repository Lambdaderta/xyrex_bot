# –ò–º–ø–æ—Ä—Ç—ã, —ç—Ç–æ—Ç —Ñ–∞–π–ª - –æ—Å–Ω–æ–≤–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏ –±–æ—Ç–∞
from aiogram import F, Router, Bot, types
from aiogram.filters import Command, CommandStart
from aiogram.types import Message, CallbackQuery
from aiogram.fsm.state import State, StatesGroup
from aiogram.fsm.context import FSMContext
from aiogram.enums import ParseMode
from app.database import add_ban, remove_ban, is_banned, get_all_bans, get_ban_info, add_to_queue
from config import CHANNEL_ID, XYREX_ID, XYREX_ANKETS, TOPIC_ID
import app.ceyboards as kb
import json


DATABASE = 'bans.db'
import aiosqlite



# –ö–ª–∞—Å—Å—ã


router = Router()


class Reg(StatesGroup):
    opinion_type = State()
    group_members = State()
    name = State()
    versus = State()
    uslovie = State()
    formatbattla = State()
    load_media = State()
    media_group = State()
    public = State()

class Proofbattle(StatesGroup):
    names = State()
    verses = State()
    tags = State()
    regone = State()
    regtwo = State()
    rules = State()
    confirm = State()
    selectone = State()
    selecttwo = State()


# –ë–∞–Ω—ã


def parse_time(time_str: str) -> int:
    time_units = {
        '–º–∏–Ω—É—Ç': 60,
        '—á–∞—Å': 3600,
        '–¥–µ–Ω—å': 86400
    }
    for unit, multiplier in time_units.items():
        if unit in time_str:
            return int(time_str.split()[0]) * multiplier
    return 86400


@router.message(CommandStart(), F.chat.type == 'private')
async def cmd_start(message: Message):
    if await is_banned(message.chat.id):
        return await message.reply('–í—ã –±—ã–ª–∏ –∑–∞–±–∞–Ω–µ–Ω—ã.')
    await message.reply('–ü—Ä–∏–≤–µ—Ç, –∂–µ–ª–∞–µ—à—å –æ–ø—É–±–ª–∏–∫–æ–≤–∞—Ç—å –º–Ω–µ–Ω–∏–µ –∏–ª–∏ –æ—Ä–≥–∞–Ω–∏–∑–æ–≤–∞—Ç—å –ø–±?', reply_markup=kb.main)


@router.message(Command("banxr"), F.chat.id == CHANNEL_ID)
async def ban_user(message: Message):
    try:
        args = message.text.split()[1:]
        if not args:
            return await message.answer("–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ: /banxr <ID> [–≤—Ä–µ–º—è] [–ø—Ä–∏—á–∏–Ω–∞]")
        
        user_id = args[0]
        duration = parse_time(' '.join(args[1:-1])) if len(args) > 2 else 86400
        reason = args[-1] if len(args) > 2 else "–ë–µ–∑ –ø—Ä–∏—á–∏–Ω—ã"
        
        try:
            await add_ban(int(user_id), duration, reason)
            ban_info = await get_ban_info(int(user_id))
            await message.answer(f"–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å {user_id} –∑–∞–±–∞–Ω–µ–Ω –¥–æ {ban_info['ban_until']} –ø–æ –ø—Ä–∏—á–∏–Ω–µ: {reason}")
        except ValueError:
            await message.answer("–ù–µ–≤–µ—Ä–Ω—ã–π ID –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è")
    except Exception as e:
        await message.answer(f"–û—à–∏–±–∫–∞: {str(e)}") 


@router.message(Command("unbanxr"), F.chat.id == CHANNEL_ID)
async def unban_user(message: Message):
    try:
        args = message.text.split()[1:]
        if not args:
            return await message.answer("–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ: /unbanxr <ID>")
        
        try:
            user_id = int(args[0])
            await remove_ban(user_id)
            await message.answer(f"–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å {user_id} —Ä–∞–∑–±–∞–Ω–µ–Ω")
        except ValueError:
            await message.answer("–ù–µ–≤–µ—Ä–Ω—ã–π ID –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è")
    except Exception as e:
        await message.answer(f"–û—à–∏–±–∫–∞: {str(e)}")  


@router.message(Command("banslist"), F.chat.id == CHANNEL_ID)
async def list_bans(message: Message):
    bans = await get_all_bans()
    
    if not bans:
        return await message.answer("–°–ø–∏—Å–æ–∫ –∑–∞–±–∞–Ω–µ–Ω–Ω—ã—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π –ø—É—Å—Ç.")
    
    response = "<b>–ó–∞–±–∞–Ω–µ–Ω–Ω—ã–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–∏:</b>\n\n"
    for ban in bans:
        user_id = ban['user_id']
        ban_until = ban['ban_until'].strftime("%d.%m.%Y %H:%M")
        reason = ban['reason']
        response += (
            f"‚Ä¢ <b>ID:</b> {user_id}\n"
            f"  <b>–î–æ:</b> {ban_until}\n"
            f"  <b>–ü—Ä–∏—á–∏–Ω–∞:</b> {reason}\n\n"
        )    
    await message.answer(response, parse_mode=ParseMode.HTML)


# –ü–ë


@router.callback_query(F.data == 'PB')
async def pbanswer(callback: CallbackQuery, state: FSMContext):
    await callback.message.edit_text(
        '–í–≤–µ–¥–∏—Ç–µ –∏–º–µ–Ω–∞ –ø–µ—Ä—Å–æ–Ω–∞–∂–µ–π, –ø–æ –ø–æ—Ä—è–¥–∫—É, —á–µ—Ä–µ–∑ –∑–∞–ø—è—Ç—É—é, —Å –ø—Ä–æ–±–µ–ª–æ–º, —Å –±–æ–ª—å—à–æ–π –±—É–∫–≤—ã.')
    await state.set_state(Proofbattle.names)


@router.message(Proofbattle.names)
async def pbnames(message: Message, state: FSMContext):
    nameslist = message.text.split(',')
    await state.update_data(names=nameslist)
    await state.set_state(Proofbattle.verses)
    await message.answer(text='–í–≤–µ–¥–∏—Ç–µ –Ω–∞–∑–≤–∞–Ω–∏—è –ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏–π/–≤–µ—Ä—Å–æ–≤, –ø–æ –ø–æ—Ä—è–¥–∫—É, —Å–Ω–∞—á–∞–ª–∞ –¥–ª—è 1 –ø–µ—Ä—Å–æ–Ω–∞–∂–∞,'
                              ' –ø–æ—Ç–æ–º –¥–ª—è 2, —á–µ—Ä–µ–∑ –∑–∞–ø—è—Ç—É—é, —Å –ø—Ä–æ–±–µ–ª–æ–º, —Å –±–æ–ª—å—à–æ–π –±—É–∫–≤—ã.')


@router.message(Proofbattle.verses)
async def pbverses(message: Message, state: FSMContext):
    verseslist = message.text.split(',')
    await state.update_data(verses=verseslist)
    await state.set_state(Proofbattle.tags)
    await message.answer(text='–í–≤–µ–¥–∏—Ç–µ —Ç–µ–≥–∏ –∏–≥—Ä–æ–∫–æ–≤, –ø–æ –ø–æ—Ä—è–¥–∫—É, —á–µ—Ä–µ–∑ –∑–∞–ø—è—Ç—É—é, —Å –ø—Ä–æ–±–µ–ª–æ–º.')


@router.message(Proofbattle.tags)
async def pbtags(message: Message, state: FSMContext):
    tagslist = message.text.split(',')
    await state.update_data(tags=tagslist)
    await message.answer(text='–í—ã–±–µ—Ä–∏—Ç–µ —Ñ–æ—Ä–º–∞—Ç –ü–ë.',
                         reply_markup=kb.pbformat)


@router.callback_query(F.data == 'classic_f')
async def five_pb(callback: CallbackQuery, state: FSMContext):
    await callback.answer('–í—ã–±—Ä–∞–Ω–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç: —Ç–∞–∫—Ç–∏–∫–∞')
    await state.update_data(formatbattla='https://t.me/c/2235550385/16')
    await callback.message.edit_text(text='–û—Ç–ø—Ä–∞–≤—å—Ç–µ —É—Å–ª–æ–≤–∏—è –≤–∞—à–µ–≥–æ –±–∞—Ç—Ç–ª–∞, –µ—Å–ª–∏ —Ç–∞–∫–æ–≤—ã—Ö –Ω–µ—Ç, –Ω–∞–ø–∏—à–∏—Ç–µ "–Ω–µ—Ç"')
    await state.set_state(Proofbattle.rules)


@router.callback_query(F.data == 'hodi_f')
async def five_pb(callback: CallbackQuery, state: FSMContext):
    await callback.answer('–í—ã–±—Ä–∞–Ω–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç: —Ö–æ–¥—ã')
    await state.update_data(formatbattla='https://t.me/c/2235550385/15')
    await callback.message.edit_text(text='–û—Ç–ø—Ä–∞–≤—å—Ç–µ —É—Å–ª–æ–≤–∏—è –≤–∞—à–µ–≥–æ –±–∞—Ç—Ç–ª–∞, –µ—Å–ª–∏ —Ç–∞–∫–æ–≤—ã—Ö –Ω–µ—Ç, –Ω–∞–ø–∏—à–∏—Ç–µ "–Ω–µ—Ç"')
    await state.set_state(Proofbattle.rules)


@router.message(Proofbattle.rules)
async def pbtags(message: Message, state: FSMContext, bot: Bot):
    forward_message = await message.forward(chat_id=XYREX_ANKETS)
    forward_message_id = forward_message.message_id
    chat = await bot.get_chat(XYREX_ANKETS)
    message_link = f"https://t.me/{chat.username}/{forward_message_id}"
    await state.update_data(rules=message_link)
    await message.answer(text='–û—Ç–ø—Ä–∞–≤—å—Ç–µ –∞–Ω–∫–µ—Ç—É(—Ä–µ–≥—É) —Å–Ω–∞—á–∞–ª–∞ –ø–µ—Ä–≤–æ–≥–æ –∏–≥—Ä–æ–∫–∞, –æ–±—è–∑–∞—Ç–µ–ª—å–Ω–æ —Å —Ñ–æ—Ç–æ –∏–ª–∏ –≤–∏–¥–µ–æ –ø–µ—Ä—Å–æ–Ω–∞–∂–∞.')
    await state.set_state(Proofbattle.regone)


@router.message(Proofbattle.regone)
async def pbregs_one(message: Message, state: FSMContext, bot: Bot):
    if message.photo:
        media_type = "photo"
        media_id = message.photo[-1].file_id
    elif message.video:
        media_type = "video"
        media_id = message.video.file_id
    else:
        await message.answer("‚ùå –ù—É–∂–Ω–æ –æ—Ç–ø—Ä–∞–≤–∏—Ç—å —Ñ–æ—Ç–æ –∏–ª–∏ –≤–∏–¥–µ–æ!")
        await state.clear()
        return

    await state.update_data(
        media1_type=media_type,
        media1_id=media_id,
        pbsher=message.from_user.id,
        username=message.from_user.username
    )

    try:
        forward_message = await message.forward(chat_id=XYREX_ANKETS)
        chat = await bot.get_chat(XYREX_ANKETS)
        message_link = f"https://t.me/{chat.username}/{forward_message.message_id}"
        await state.update_data(link_one=message_link)
        await message.answer("‚úÖ –ê–Ω–∫–µ—Ç–∞ –ø–µ—Ä–≤–æ–≥–æ –∏–≥—Ä–æ–∫–∞ –ø—Ä–∏–Ω—è—Ç–∞! –¢–µ–ø–µ—Ä—å –æ—Ç–ø—Ä–∞–≤—å—Ç–µ –∞–Ω–∫–µ—Ç—É –≤—Ç–æ—Ä–æ–≥–æ –∏–≥—Ä–æ–∫–∞.")
        await state.set_state(Proofbattle.regtwo)
    except Exception as e:
        await message.answer(f"‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ –∞–Ω–∫–µ—Ç—ã: {str(e)}")
        await state.clear()


@router.message(Proofbattle.regtwo)
async def pbregs_two(message: Message, state: FSMContext, bot: Bot):
    if message.photo:
        media_type = "photo"
        media_id = message.photo[-1].file_id
    elif message.video:
        media_type = "video"
        media_id = message.video.file_id
    else:
        await message.answer("‚ùå –ù—É–∂–Ω–æ –æ—Ç–ø—Ä–∞–≤–∏—Ç—å —Ñ–æ—Ç–æ –∏–ª–∏ –≤–∏–¥–µ–æ!")
        await state.clear()
        return

    await state.update_data(
        media2_type=media_type,
        media2_id=media_id
    )

    try:
        forward_message = await message.forward(chat_id=XYREX_ANKETS)
        chat = await bot.get_chat(XYREX_ANKETS)
        message_link = f"https://t.me/{chat.username}/{forward_message.message_id}"
        await state.update_data(link_two=message_link)
        
        data = await state.get_data()
        caption = f"""
<blockquote><b>–ü–ï–†–°–û–ù–ê–õ–¨–ù–´–ô –ü–†–£–§-–ë–ê–¢–¢–õ</b></blockquote>

Player 1: {data['tags'][0]}
 <b><a href="{data['link_one']}">{data['names'][0]}</a> ‚Äî ¬´{data['verses'][0]}¬ª</b>


    <b>‚ãÜ V-E-R-S-U-S ‚ãÜ</b>
            
 <b><a href="{data['link_two']}">{data['names'][1]}</a> ‚Äî ¬´{data['verses'][1]}¬ª</b>
<b>Player 2: {data['tags'][1]}</b>


‚û•„Äå<a href='{data['formatbattla']}'>–ø—Ä–∞–≤–∏–ª–∞ –±–æ–µ–≤</a>„Äç
‚û•„Äå<a href='https://t.me/xyrex_realm/27510'>—Å–ø–∏—Å–æ–∫ —Å—É–¥–µ–π</a>„Äç
‚û•„Äå<a href='https://t.me/Xyrex_Fights/12643'>—É—Å–ª–æ–≤–∏—è –±–∞—Ç—Ç–ª–∞</a>„Äç
"""

        media_group = []
        
        if data['media1_type'] == 'photo':
            media_group.append(types.InputMediaPhoto(media=data["media1_id"], caption=caption, parse_mode=ParseMode.HTML))
        else:
            media_group.append(types.InputMediaVideo(media=data["media1_id"], caption=caption, parse_mode=ParseMode.HTML))
        
        if data['media2_type'] == 'photo':
            media_group.append(types.InputMediaPhoto(media=data["media2_id"]))
        else:
            media_group.append(types.InputMediaVideo(media=data["media2_id"]))
        
        soo = await bot.send_media_group(chat_id=data['pbsher'], media=media_group)
        message_id = [msg.message_id for msg in soo]
        await state.update_data(text=caption)
        await state.update_data(soo_id=message_id[0])
        await bot.send_message(
            chat_id=data['pbsher'],
            text='–í—Å–µ –ª–∏ –≤–µ—Ä–Ω–æ?\n–ü—Ä–∏ –Ω–∞–∂–∞—Ç–∏–∏ –Ω–∞ –≥–∞–ª–∫—É –ü–ë –æ—Ç–ø—Ä–∞–≤–∏—Ç—Å—è –Ω–∞ –º–æ–¥–µ—Ä–∞—Ü–∏—é.',
            reply_markup=kb.accept
        )
        await state.set_state(Proofbattle.selecttwo)
        
    except Exception as e:
        await message.answer(f"‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ —Ñ–æ—Ä–º–∏—Ä–æ–≤–∞–Ω–∏–∏ –ø–æ—Å—Ç–∞: {str(e)}")
        await state.clear()

    

@router.callback_query(F.data.in_(["right", "wrong"]))
async def five_pb(callback: CallbackQuery, state: FSMContext, bot: Bot):
    if callback.data == 'right':
        try:
            data = await state.get_data()
            
            required_keys = ['media1_id', 'media2_id', 'link_one', 'link_two', 
                            'names', 'verses', 'tags', 'formatbattla', 'text',
                            'pbsher', 'username']
            for key in required_keys:
                if key not in data:
                    raise KeyError(f"Missing required key: {key}")

            media_group = []
            
            if data.get('media1_type') == 'photo':
                media_group.append(types.InputMediaPhoto(
                    media=data["media1_id"], 
                    caption=data['text'], 
                    parse_mode=ParseMode.HTML
                ))
            else:
                media_group.append(types.InputMediaVideo(
                    media=data["media1_id"], 
                    caption=data['text'], 
                    parse_mode=ParseMode.HTML
                ))

            if data.get('media2_type') == 'photo':
                media_group.append(types.InputMediaPhoto(
                    media=data["media2_id"]
                ))
            else:
                media_group.append(types.InputMediaVideo(
                    media=data["media2_id"]
                ))

            await bot.send_media_group(
                chat_id=CHANNEL_ID, 
                media=media_group, 
                message_thread_id=TOPIC_ID
            )

            await bot.send_poll(
                chat_id=CHANNEL_ID,
                question='‚öîÔ∏è–û–ë–°–£–ñ–î–ï–ù–ò–ï –ë–ê–¢–¢–õ–ê‚öîÔ∏è\n–ö—Ç–æ –ø–æ–±–µ–¥–∏—Ç –ø–æ –≤–∞—à–µ–º—É –º–Ω–µ–Ω–∏—é?',
                options=data['names'],
                is_anonymous=True,
                type='regular',
                message_thread_id=TOPIC_ID,
                reply_markup=kb.publicpb
            )

            await bot.send_message(
                chat_id=CHANNEL_ID,
                message_thread_id=TOPIC_ID,
                text=f'ID –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è: {data["pbsher"]}\n'
                     f'Username: @{data["username"]}\n'
                     f'–ö–æ–º–∞–Ω–¥–∞ –¥–ª—è –±–∞–Ω–∞: /banxr {data["pbsher"]}'
            )

            await callback.message.edit_text(
                '‚úÖ –û–∂–∏–¥–∞–π—Ç–µ –ø—Ä–æ–≤–µ—Ä–∫—É. –ï—Å–ª–∏ –±–∞—Ç—Ç–ª –¥–æ–ª–≥–æ –Ω–µ –Ω–∞—á–∏–Ω–∞–µ—Ç—Å—è, '
                '–æ–±—Ä–∞—Ç–∏—Ç–µ—Å—å –∫ –æ—Ä–≥–∞–Ω–∏–∑–∞—Ç–æ—Ä–∞–º.\n'
                '–ß—Ç–æ–±—ã –Ω–∞—á–∞—Ç—å –∑–∞–Ω–æ–≤–æ, –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ /start'
            )
            await state.clear()

        except KeyError as e:
            await callback.message.answer(
                f'‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ –¥–∞–Ω–Ω—ã—Ö: {str(e)}\n'
                '–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –Ω–∞—á–Ω–∏—Ç–µ —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—é –∑–∞–Ω–æ–≤–æ',
                reply_markup=kb.main
            )
            await state.clear()

        except Exception as e:
            await callback.message.answer(
                '‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –Ω–µ–ø—Ä–µ–¥–≤–∏–¥–µ–Ω–Ω–∞—è –æ—à–∏–±–∫–∞\n'
                '–ü–æ–ø—Ä–æ–±—É–π—Ç–µ –Ω–∞—á–∞—Ç—å —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—é –∑–∞–Ω–æ–≤–æ',
                reply_markup=kb.main
            )
            await state.clear()

    else:
        await callback.answer('–ü–æ—Å—Ç –æ—Ç–º–µ–Ω–µ–Ω')
        await callback.message.edit_text(
            '‚ùå –í–∞—à –ø–æ—Å—Ç –æ—Ç–º–µ–Ω–µ–Ω\n'
            '–ß—Ç–æ–±—ã –Ω–∞—á–∞—Ç—å –∑–∞–Ω–æ–≤–æ, –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ /start'
        )
        await state.clear()


@router.callback_query(F.data.in_(["publicpb", "nopublic"]))
async def handle_callback(call: CallbackQuery):
    if call.data == "publicpb":
        try:
            message_ids = json.dumps([call.message.message_id])
            await add_to_queue(post_type='pb', post_id=call.message.message_id, message_ids=message_ids)
            await call.answer("‚úÖ –ü–æ—Å—Ç –¥–æ–±–∞–≤–ª–µ–Ω –≤ –æ—á–µ—Ä–µ–¥—å –Ω–∞ –ø—É–±–ª–∏–∫–∞—Ü–∏—é")
        except Exception as e:
            await call.answer("‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –¥–æ–±–∞–≤–ª–µ–Ω–∏–∏ –≤ –æ—á–µ—Ä–µ–¥—å")
            print(f"–û—à–∏–±–∫–∞ –æ—á–µ—Ä–µ–¥–∏: {str(e)}")
    elif call.data == "nopublic":
        await call.message.delete()
        await call.answer("üóë –ë–æ–π –æ—Ç–º–µ–Ω–µ–Ω")


@router.callback_query(F.data == 'mnenie')
async def mnenie_post(callback: CallbackQuery, state: FSMContext):
    await callback.answer()
    await callback.message.edit_text(
        'üé≠ –í—ã–±–µ—Ä–∏—Ç–µ —Ç–∏–ø –º–Ω–µ–Ω–∏—è:',
        reply_markup=kb.opinion_type_select
    )
    await state.set_state(Reg.opinion_type)


@router.callback_query(F.data.in_(['single', 'group']), Reg.opinion_type)
async def process_opinion_type(callback: CallbackQuery, state: FSMContext):
    await state.update_data(opinion_type=callback.data)
    if callback.data == 'group':
        await callback.message.answer('üë• –í–≤–µ–¥–∏—Ç–µ —Ç–µ–≥–∏/–Ω–∏–∫–∏ —É—á–∞—Å—Ç–Ω–∏–∫–æ–≤ —á–µ—Ä–µ–∑ –∑–∞–ø—è—Ç—É—é:')
        await state.set_state(Reg.group_members)
    else:
        await callback.message.answer('üé≠ –í–≤–µ–¥–∏—Ç–µ –∏–º—è –ø–µ—Ä—Å–æ–Ω–∞–∂–∞:')
        await state.set_state(Reg.name)


@router.message(Reg.name)
async def process_name(message: Message, state: FSMContext):
    await state.update_data(name=message.text)
    await message.answer('–í–≤–µ–¥–∏—Ç–µ –∏–º–µ–Ω–∞ –ø–µ—Ä—Å–æ–Ω–∞–∂–µ–π/–≤—Å–µ–ª–µ–Ω–Ω—ã—Ö —á–µ—Ä–µ–∑ –∑–∞–ø—è—Ç—É—é:')
    await state.set_state(Reg.versus)


@router.message(Reg.versus)
async def process_versus(message: Message, state: FSMContext):
    versus = '\n'.join([f'‚û£ {v.strip()}' for v in message.text.split(',')])
    await state.update_data(versus=versus)
    await message.answer('–í–≤–µ–¥–∏—Ç–µ —É—Å–ª–æ–≤–∏—è –±–∞—Ç—Ç–ª–∞:')
    await state.set_state(Reg.uslovie)


@router.message(Reg.uslovie)
async def process_uslovie(message: Message, state: FSMContext):
    await state.update_data(uslovie=message.text)
    await message.answer('–í—ã–±–µ—Ä–∏—Ç–µ —Ñ–æ—Ä–º–∞—Ç –æ–±—Å—É–∂–¥–µ–Ω–∏—è:', reply_markup=kb.formatselect)
    await state.set_state(Reg.formatbattla)


@router.callback_query(F.data.in_(['pb_format', 'gch', 'discussion_format']), Reg.formatbattla)
async def process_format(callback: CallbackQuery, state: FSMContext):
    format_text = {
        'pb_format': '–ø—Ä—É—Ñ–±–∞—Ç—Ç–ª',
        'gch': '–≥–æ–ª–æ—Å–æ–≤–æ–π —á–∞—Ç',
        'discussion_format': '–¥–∏—Å–∫—É—Å—Å–∏—è'
    }[callback.data]

    await state.update_data(formatbattla=format_text)
    await callback.message.answer('üì∏ –û—Ç–ø—Ä–∞–≤—å—Ç–µ —Ñ–æ—Ç–æ/–≤–∏–¥–µ–æ –ø–µ—Ä—Å–æ–Ω–∞–∂–∞:')
    await callback.message.delete()
    await state.set_state(Reg.load_media)


@router.message(Reg.group_members)
async def process_group_members(message: Message, state: FSMContext):
    members = [m.strip() for m in message.text.split(',')]
    await state.update_data(members=members)
    await message.answer('üé≠ –í–≤–µ–¥–∏—Ç–µ –∏–º—è –ø–µ—Ä—Å–æ–Ω–∞–∂–∞:')
    await state.set_state(Reg.name)


@router.message(Reg.load_media, F.photo | F.video)
async def process_media(message: Message, state: FSMContext, bot: Bot):
    data = await state.get_data()
    media_type = 'photo' if message.photo else 'video'
    media_id = message.photo[-1].file_id if media_type == 'photo' else message.video.file_id

    if data['opinion_type'] == 'group':
        media_list = data.get('media_list', [])
        media_list.append((media_type, media_id))
        await state.update_data(media_list=media_list)
        
        
        if len(media_list) == len(data['members']):
            caption = (
                f"<b>‚öîÔ∏è –ü–ï–†–°–û–ù–ê–õ–¨–ù–ê–Ø –ü–û–ó–ò–¶–ò–Ø</b>\n"
                f"<b>‚Äî @{message.from_user.username}</b>\n"
                f"‚û• <b><u>{data['name']}</u> –∞–Ω–Ω–∏–≥–∏–ª–∏—Ä—É–µ—Ç –≤—Å–µ—Ö –ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–Ω—ã—Ö:</b>\n"
                f"<blockquote><b>{data['versus']}</b></blockquote>\n"
                f"<b>–£—Å–ª–æ–≤–∏—è –±–∞—Ç—Ç–ª–∞: {data['uslovie']}</b>\n"
                f"<b>–§–æ—Ä–º–∞—Ç: {data['formatbattla']}</b>"
            )
            media_group = []
            for mt, mid in media_list:
                media = types.InputMediaPhoto(media=mid) if mt == 'photo' else types.InputMediaVideo(media=mid)
                media_group.append(media)
            media_group[0].caption = caption
            media_group[0].parse_mode = ParseMode.HTML
            
            sent_msgs = await message.answer_media_group(media=media_group, reply_markup=kb.public)
            message_ids = [msg.message_id for msg in sent_msgs]
            
            async with aiosqlite.connect(DATABASE) as db:
                cursor = await db.execute('''
                    INSERT INTO opinions (opinion_type, name, versus, uslovie, formatbattla, media_id, author, username)
                    VALUES (?, ?, ?, ?, ?, ?, ?, ?)
                ''', (
                    data['opinion_type'],
                    data['name'],
                    data['versus'],
                    data['uslovie'],
                    data['formatbattla'],
                    json.dumps([(mt, mid) for mt, mid in media_list]),
                    json.dumps(data['members']),
                    message.from_user.username
                ))
                await db.commit()
                opinion_id = cursor.lastrowid
            
            await add_to_queue(post_type='opinion', post_id=opinion_id, message_ids=json.dumps(message_ids))
            await state.clear()
    else:
        caption = (
            f"<b>‚öîÔ∏è –ü–ï–†–°–û–ù–ê–õ–¨–ù–ê–Ø –ü–û–ó–ò–¶–ò–Ø</b>\n"
            f"<b>‚Äî @{message.from_user.username}</b>\n"
            f"‚û• <b><u>{data['name']}</u> –∞–Ω–Ω–∏–≥–∏–ª–∏—Ä—É–µ—Ç –≤—Å–µ—Ö –ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–Ω—ã—Ö:</b>\n"
            f"<blockquote><b>{data['versus']}</b></blockquote>\n"
            f"<b>–£—Å–ª–æ–≤–∏—è –±–∞—Ç—Ç–ª–∞: {data['uslovie']}</b>\n"
            f"<b>–§–æ—Ä–º–∞—Ç: {data['formatbattla']}</b>"
        )

        if media_type == 'photo':
            sent_msg = await message.answer_photo(
                photo=media_id,
                caption=caption,
                parse_mode=ParseMode.HTML,
                reply_markup=kb.public
            )
        else:
            sent_msg = await message.answer_video(
                video=media_id,
                caption=caption,
                parse_mode=ParseMode.HTML,
                reply_markup=kb.public
            )

        async with aiosqlite.connect(DATABASE) as db:
            cursor = await db.execute('''
                INSERT INTO opinions (opinion_type, name, versus, uslovie, formatbattla, media_type, media_id, author, username)
                VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
            ''', (
                data['opinion_type'],
                data['name'],
                data['versus'],
                data['uslovie'],
                data['formatbattla'],
                media_type,
                media_id,
                json.dumps([message.from_user.username]),
                message.from_user.username
            ))
            await db.commit()
            opinion_id = cursor.lastrowid

        await add_to_queue(post_type='opinion', post_id=opinion_id)
        await state.clear()

@router.callback_query(F.data.in_(["yes", "no"]))
async def handle_callback(call: CallbackQuery, state: FSMContext, bot: Bot):
    if call.data == "yes":
        try:
            data = await state.get_data()
            message_ids = [call.message.message_id]

            await add_to_queue(
                message_ids=message_ids,
                chat_id=CHANNEL_ID,
                topic_id=TOPIC_ID,
                post_type='opinion',
                additional_data=json.dumps(data)
            )
            await call.answer("‚úÖ –ú–Ω–µ–Ω–∏–µ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ –Ω–∞ –º–æ–¥–µ—Ä–∞—Ü–∏—é!")
        except Exception as e:
            await call.answer("‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –¥–æ–±–∞–≤–ª–µ–Ω–∏–∏ –≤ –æ—á–µ—Ä–µ–¥—å")
            print(f"–û—à–∏–±–∫–∞: {str(e)}")
    else:
        await call.message.delete()
        await call.answer("‚ùå –ü–æ—Å—Ç –æ—Ç–º–µ–Ω–µ–Ω")
    await state.clear()


# data = await state.get_data()
    # await message.answer_photo(
    #     photo=data['photo'],
    #     caption=f'<b>‚öîÔ∏è –ü–µ—Ä—Å–æ–Ω–∞–ª—å–Ω–∞—è –ø–æ–∑–∏—Ü–∏—è‚öîÔ∏è\n</b>'
    #             f'\n'
    #             f'<b>‚Äî @{data["username"]}\n</b>'
    #             f'\n'
    #             f'‚û• <b><u>{data["name"]}</u> –∞–Ω–Ω–∏–≥–∏–ª–∏—Ä—É–µ—Ç –≤—Å–µ—Ö –Ω–∏–∂–µ–ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–Ω—ã—Ö –ø–µ—Ä—Å–æ–Ω–∞–∂–µ–π/–≤—Å–µ–ª–µ–Ω–Ω—ã—Ö:</b>\n'
    #             f'<blockquote><b>{data["versus"]}</b></blockquote>\n'
    #             f'<b>–£—Å–ª–æ–≤–∏—è –±–∞—Ç—Ç–ª–∞: {data["uslovie"]}</b>\n'
    #             f'<b>–§–æ—Ä–º–∞—Ç: {data["formatbattla"]}</b>',
    #     parse_mode=ParseMode.HTML
    # )

    # data = await state.get_data()
    # await bot.send_photo(
    #     chat_id=CHANNEL_ID,
    #     message_thread_id=TOPIC_ID,
    #     photo=data['photo'],
    #     caption=f'<b>‚öîÔ∏è –ü–µ—Ä—Å–æ–Ω–∞–ª—å–Ω–∞—è –ø–æ–∑–∏—Ü–∏—è‚öîÔ∏è\n</b>'
    #             f'\n'
    #             f'<b>‚Äî @{data["username"]}\n</b>'
    #             f'\n'
    #             f'‚û• <b><u>{data["name"]}</u> –∞–Ω–Ω–∏–≥–∏–ª–∏—Ä—É–µ—Ç –≤—Å–µ—Ö –Ω–∏–∂–µ–ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–Ω—ã—Ö –ø–µ—Ä—Å–æ–Ω–∞–∂–µ–π/–≤—Å–µ–ª–µ–Ω–Ω—ã—Ö:</b>\n'
    #             f'<blockquote><b>{data["versus"]}</b></blockquote>\n'
    #             f'<b>–£—Å–ª–æ–≤–∏—è –±–∞—Ç—Ç–ª–∞: {data["uslovie"]}</b>\n'
    #             f'<b>–§–æ—Ä–º–∞—Ç: {data["formatbattla"]}</b>',
    #     parse_mode=ParseMode.HTML,
    #     reply_markup=kb.public
    # )
    # user_id = message.from_user.id
    # username = message.from_user.username
    # full_name = message.from_user.full_name
    # await bot.send_message(chat_id=CHANNEL_ID,
    #                        message_thread_id=TOPIC_ID,
    #                        text=f'ID –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è:{user_id}\n'
    #                             f'–¢–µ–≥: @{username}, –Ω–∏–∫, –µ—Å–ª–∏ –Ω–µ—Ç—É —Ç–µ–≥–∞: {full_name}'
    #                             f'–ß—Ç–æ–±—ã –∑–∞–±–∞–Ω–∏—Ç—å "/banxr ID"\n'
    #                             f'–î–ª—è —Ä–∞–∑–±–∞–Ω–∞ "/unbanxr ID"')
    # await message.answer(text='–í–∞—à–µ –º–Ω–µ–Ω–∏–µ –±—ã–ª–æ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ –Ω–∞ –ø—Ä–æ–≤–µ—Ä–∫—É –º–æ–¥–µ—Ä–∞—Ü–∏–∏, –≤–∞–º –æ—Å—Ç–∞–ª–æ—Å—å —Ç–æ–ª—å–∫–æ –ø–æ–¥–æ–∂–¥–∞—Ç—å!\n'
    #                           "–ß—Ç–æ–±—ã –Ω–∞—á–∞—Ç—å —Å–Ω–æ–≤–∞, –ø—Ä–æ–ø–∏—à–∏—Ç–µ –∫–æ–º–∞–Ω–¥—É /start")
    # await state.clear()


# @router.callback_query(F.data.in_(["yes", "no"]))
# async def handle_callback(call: CallbackQuery, state: FSMContext, bot: Bot):
#     if call.data == "yes":
#         try:
#             data = await state.get_data()
#             message_ids = [call.message.message_id]
            
#             # –î–æ–±–∞–≤–ª—è–µ–º –≤ –æ—á–µ—Ä–µ–¥—å —Å –ø—Ä–∞–≤–∏–ª—å–Ω—ã–º–∏ –ø–∞—Ä–∞–º–µ—Ç—Ä–∞–º–∏
#             await add_to_queue(
#                 message_ids=message_ids,
#                 chat_id=CHANNEL_ID,
#                 topic_id=TOPIC_ID,
#                 post_type='opinion',
#                 additional_data=json.dumps(data)
#             )
#             await call.answer("‚úÖ –ú–Ω–µ–Ω–∏–µ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ –Ω–∞ –º–æ–¥–µ—Ä–∞—Ü–∏—é!")
#         except Exception as e:
#             await call.answer("‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –¥–æ–±–∞–≤–ª–µ–Ω–∏–∏ –≤ –æ—á–µ—Ä–µ–¥—å")
#             print(f"–û—à–∏–±–∫–∞: {str(e)}")
#     else:
#         await call.message.delete()
#         await call.answer("‚ùå –ü–æ—Å—Ç –æ—Ç–º–µ–Ω–µ–Ω")
#     await state.clear()

import aiosqlite
from datetime import datetime, timedelta
import json
from config import XYREX_ID, CHANNEL_ID, TOPIC_ID


DATABASE = 'bans.db'


async def create_db():
    async with aiosqlite.connect(DATABASE) as db:
        await db.execute('''
            CREATE TABLE IF NOT EXISTS bans (
                user_id INTEGER PRIMARY KEY,
                ban_until TIMESTAMP NOT NULL,
                reason TEXT DEFAULT 'No reason specified'
            )
        ''')
        await db.execute('''
            CREATE TABLE IF NOT EXISTS proofbattles (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                names JSON NOT NULL,
                verses JSON NOT NULL,
                tags JSON NOT NULL,
                formatbattla TEXT NOT NULL,
                rules TEXT NOT NULL,
                media1_type TEXT NOT NULL,
                media1_id TEXT NOT NULL,
                media2_type TEXT NOT NULL,
                media2_id TEXT NOT NULL,
                text TEXT NOT NULL,
                pbsher INTEGER NOT NULL,
                username TEXT NOT NULL
            )
        ''')
        await db.execute('''
            CREATE TABLE IF NOT EXISTS opinions (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                opinion_type TEXT NOT NULL,
                name TEXT NOT NULL,
                versus TEXT NOT NULL,
                uslovie TEXT NOT NULL,
                formatbattla TEXT NOT NULL,
                media_list JSON NOT NULL, 
                media_list JSON NOT NULL,
                username TEXT NOT NULL
            )
        ''')
        await db.execute('''
            CREATE TABLE IF NOT EXISTS post_queue (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                post_type TEXT NOT NULL,
                db_post_id INTEGER NOT NULL,
                scheduled_time TIMESTAMP NOT NULL,
                status TEXT DEFAULT 'pending',
                moderation_message_ids TEXT NOT NULL
                attempts INTEGER DEFAULT 0
            )
        ''')
        await db.commit()


async def add_ban(user_id: int, duration: int = 86400, reason: str = "No reason"):
    ban_until = datetime.now() + timedelta(seconds=duration)
    async with aiosqlite.connect(DATABASE) as db:
        await db.execute('''
            INSERT OR REPLACE INTO bans (user_id, ban_until, reason)
            VALUES (?, ?, ?)
        ''', (user_id, ban_until.timestamp(), reason))
        await db.commit()


async def remove_ban(user_id: int):
    async with aiosqlite.connect(DATABASE) as db:
        await db.execute('DELETE FROM bans WHERE user_id = ?', (user_id,))
        await db.commit()


async def is_banned(user_id: int) -> bool:
    async with aiosqlite.connect(DATABASE) as db:
        cursor = await db.execute('SELECT ban_until FROM bans WHERE user_id = ?', (user_id,))
        result = await cursor.fetchone()
        
        if result:
            ban_until = datetime.fromtimestamp(result[0])
            if datetime.now() > ban_until:
                await remove_ban(user_id)
                return False
            return True
    return False


async def get_ban_info(user_id: int) -> dict:
    async with aiosqlite.connect(DATABASE) as db:
        cursor = await db.execute('SELECT ban_until, reason FROM bans WHERE user_id = ?', (user_id,))
        result = await cursor.fetchone()
        
        if result:
            return {
                'ban_until': datetime.fromtimestamp(result[0]),
                'reason': result[1]
            }
    return None


async def get_all_bans() -> list:
    async with aiosqlite.connect(DATABASE) as db:
        cursor = await db.execute('SELECT user_id, ban_until, reason FROM bans')
        rows = await cursor.fetchall()
        return [
            {
                'user_id': row[0],
                'ban_until': datetime.fromtimestamp(row[1]),
                'reason': row[2]
            } for row in rows
        ]


async def cleanup_expired_bans():
    async with aiosqlite.connect(DATABASE) as db:
        await db.execute('DELETE FROM bans WHERE ban_until < ?', (datetime.now().timestamp(),))
        await db.commit()


async def add_to_queue(post_type: str, post_id: int, message_ids: str):
    async with aiosqlite.connect(DATABASE) as db:
        cursor = await db.execute('''
            SELECT MAX(scheduled_time) FROM post_queue WHERE status = 'pending'
        ''')
        last_time = await cursor.fetchone()
        next_time = datetime.now() + timedelta(minutes=1) 
        if last_time[0]:
            last_time = datetime.fromtimestamp(last_time[0])
            next_time = max(next_time, last_time + timedelta(minutes=1))
        
        await db.execute('''
            INSERT INTO post_queue (post_type, post_id, message_ids, scheduled_time)
            VALUES (?, ?, ?, ?)
        ''', (post_type, post_id, message_ids, next_time.timestamp()))
        await db.commit()


async def get_next_post():
    async with aiosqlite.connect(DATABASE) as db:
        db.row_factory = aiosqlite.Row
        
        cursor = await db.execute('''
            SELECT * FROM post_queue 
            WHERE status = 'pending' 
            AND scheduled_time <= ?
            ORDER BY scheduled_time 
            LIMIT 1
        ''', (datetime.now().timestamp(),))
        
        return await cursor.fetchone()


async def update_post(post_id: int, status: str):
    async with aiosqlite.connect(DATABASE) as db:
        await db.execute('''
            UPDATE post_queue 
            SET status = ?, 
                attempts = attempts + 1 
            WHERE id = ?
        ''', (status, post_id))
        await db.commit()


async def cleanup_queue():
    async with aiosqlite.connect(DATABASE) as db:
        await db.execute('''
            DELETE FROM post_queue 
            WHERE scheduled_time < ?
        ''', ((datetime.now() - timedelta(days=3)).timestamp(),))
        await db.commit()